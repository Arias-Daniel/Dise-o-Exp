<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puzzle - Dise√±o de Experimentos</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@500&display=swap" rel="stylesheet">
    <style>
        /* ESTILOS GENERALES */
        :root {
            --primary-color: #2c3e50;
            --accent-color: #3498db;
            --success-color: #27ae60;
            --text-light: #ecf0f1;
            --bg-color: #eef2f3;
            --timer-bg: #fff;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background: var(--bg-color);
            color: #333;
            user-select: none; /* Evita selecci√≥n de texto al arrastrar */
        }

        header {
            background-color: var(--primary-color);
            color: var(--text-light);
            width: 100%;
            padding: 1rem 0;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        h1 { margin: 0; font-size: 1.8rem; font-weight: 600; letter-spacing: 1px; }
        h2 { margin: 5px 0 0; font-size: 1rem; font-weight: 300; opacity: 0.9; }

        /* --- NUEVO: PANEL DE ESTAD√çSTICAS (CRON√ìMETRO) --- */
        .dashboard {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            z-index: 10;
        }

        .stat-card {
            background: var(--timer-bg);
            padding: 10px 25px;
            border-radius: 50px; /* Bordes redondeados modernos */
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            gap: 10px;
            border-left: 5px solid var(--accent-color);
            transition: transform 0.2s;
        }

        .stat-card:hover { transform: translateY(-2px); }

        .stat-label {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #7f8c8d;
            font-weight: bold;
        }

        .stat-value {
            font-family: 'Roboto Mono', monospace; /* Fuente tipo digital */
            font-size: 1.5rem;
            color: var(--primary-color);
            font-weight: 600;
            min-width: 140px; /* Evita que salte al cambiar n√∫meros */
            text-align: right;
        }

        .icon { font-size: 1.2rem; }

        /* --- CONTENEDOR DEL JUEGO --- */
        #game-container {
            position: relative;
            box-shadow: 0 15px 35px rgba(0,0,0,0.25);
            border: 8px solid #fff;
            border-radius: 6px;
            background-color: #bdc3c7; 
            line-height: 0; /* Elimina espacios extra */
        }

        canvas {
            display: block;
            cursor: grab;
        }
        canvas:active { cursor: grabbing; }

        footer {
            margin-top: 30px;
            font-size: 0.9rem;
            color: #7f8c8d;
            text-align: center;
            padding-bottom: 20px;
        }

        .credits {
            font-weight: bold;
            color: var(--primary-color);
        }

        /* --- MENSAJE DE VICTORIA --- */
        #win-message {
            display: none;
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: #fff;
            color: #333;
            padding: 40px 60px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
            z-index: 100;
            border-top: 10px solid var(--success-color);
            animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popIn {
            from { opacity: 0; transform: translate(-50%, -60%) scale(0.9); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        #win-message h1 { color: var(--success-color); margin-bottom: 10px; }
        
        .final-time {
            font-size: 2rem;
            font-family: 'Roboto Mono', monospace;
            color: var(--primary-color);
            margin: 20px 0;
            display: block;
            background: #f1f2f6;
            padding: 10px;
            border-radius: 8px;
        }

        button.btn-restart {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1rem;
            border-radius: 25px;
            cursor: pointer;
            transition: background 0.3s;
            text-transform: uppercase;
            font-weight: bold;
            letter-spacing: 1px;
        }
        button.btn-restart:hover { background: #2980b9; box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4); }

        /* Overlay oscuro para cuando ganas */
        #overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(3px);
            z-index: 99;
        }
    </style>
</head>
<body>

    <header>
        <h1>Dise√±o de Experimentos</h1>
        <h2>Prueba de Habilidad Espacial</h2>
    </header>

    <div class="dashboard">
        <div class="stat-card">
            <span class="icon">‚è±Ô∏è</span>
            <div>
                <div class="stat-label">Tiempo Transcurrido</div>
                <div class="stat-value" id="timer">00:00:00</div>
            </div>
        </div>
        <div class="stat-card">
            <span class="icon">üß©</span>
            <div>
                <div class="stat-label">Progreso</div>
                <div class="stat-value" id="progress">0%</div>
            </div>
        </div>
    </div>

    <div id="game-container">
        <canvas id="miCanvas"></canvas>
    </div>

    <div id="overlay"></div>
    <div id="win-message">
        <h1>¬°Experimento Completado!</h1>
        <p>Has ensamblado el rompecabezas exitosamente.</p>
        <span class="final-time" id="final-time-display">00:00:00</span>
        <p>Registra este tiempo en tu tabla de datos.</p>
        <button class="btn-restart" onclick="location.reload()">Nuevo Intento</button>
    </div>

    <footer>
        Desarrollado por:<br>
        <span class="credits">Daniel Enrique Arias Montero & Abraham Jos√© G√≥mez Sarmiento</span>
    </footer>

    <script>
        const canvas = document.getElementById('miCanvas');
        const ctx = canvas.getContext('2d');
        const winMsg = document.getElementById('win-message');
        const overlay = document.getElementById('overlay');
        const timerDisplay = document.getElementById('timer');
        const finalTimeDisplay = document.getElementById('final-time-display');
        const progressDisplay = document.getElementById('progress');
        
        // CONFIGURACI√ìN
        const FILAS = 8;
        const COLUMNAS = 8;
        const TOTAL_PIEZAS = FILAS * COLUMNAS;
        const RUTA_IMAGEN = 'foto.jpg'; // Aseg√∫rate de tener esta imagen
        const MARGEN_ERROR = 25; 
        
        let piezas = [];
        let anchoPieza, altoPieza;
        let piezaSeleccionada = null;
        let img = new Image();
        let tamanoPestana; 

        // VARIABLES DEL CRON√ìMETRO
        let tiempoInicio = 0;
        let intervaloTimer = null;
        let cronometroAndando = false;
        let tiempoFinal = "";

        img.src = RUTA_IMAGEN;
        
        img.onload = function() {
            // Ajustar canvas al tama√±o de imagen (m√°ximo de pantalla razonable)
            let scale = 1;
            if (img.width > 800) scale = 800 / img.width;
            
            canvas.width = img.width * scale;
            canvas.height = img.height * scale;
            
            // Dibujamos la imagen escalada internamente si es necesario
            // Para simplificar, asumimos que el c√°lculo de piezas se basa en el canvas
            anchoPieza = canvas.width / COLUMNAS;
            altoPieza = canvas.height / FILAS;
            tamanoPestana = Math.min(anchoPieza, altoPieza) * 0.2;

            inicializarPiezas(scale);
            mezclarPiezas();
            dibujarJuego();
        };

        // L√ìGICA DEL CRON√ìMETRO
        function formatearTiempo(ms) {
            let totalSegundos = Math.floor(ms / 1000);
            let minutos = Math.floor(totalSegundos / 60);
            let segundos = totalSegundos % 60;
            let centesimas = Math.floor((ms % 1000) / 10); // Mostramos cent√©simas para look cient√≠fico

            return `${pad(minutos)}:${pad(segundos)}:${pad(centesimas)}`;
        }

        function pad(num) {
            return num.toString().padStart(2, '0');
        }

        function iniciarCronometro() {
            if (!cronometroAndando) {
                tiempoInicio = Date.now();
                cronometroAndando = true;
                // Actualizar cada 30ms para efecto visual fluido
                intervaloTimer = setInterval(() => {
                    const ahora = Date.now();
                    const diferencia = ahora - tiempoInicio;
                    timerDisplay.textContent = formatearTiempo(diferencia);
                }, 30);
                
                // Efecto visual: borde azul al iniciar
                document.querySelector('.stat-card').style.borderLeftColor = "#e74c3c"; // Rojo indicando grabaci√≥n
            }
        }

        function detenerCronometro() {
            if (cronometroAndando) {
                clearInterval(intervaloTimer);
                cronometroAndando = false;
                // Guardar tiempo final exacto
                const diferencia = Date.now() - tiempoInicio;
                tiempoFinal = formatearTiempo(diferencia);
                timerDisplay.textContent = tiempoFinal;
                document.querySelector('.stat-card').style.borderLeftColor = "#27ae60"; // Verde al finalizar
            }
        }

        function actualizarProgreso() {
            const colocadas = piezas.filter(p => p.bloqueada).length;
            const porcentaje = Math.round((colocadas / TOTAL_PIEZAS) * 100);
            progressDisplay.textContent = porcentaje + "%";
        }

        // L√ìGICA DEL JUEGO
        function inicializarPiezas(scale) {
            piezas = [];
            let formas = []; 
            
            // Generar formas aleatorias
            for (let i = 0; i < FILAS; i++) {
                formas[i] = [];
                for (let j = 0; j < COLUMNAS; j++) {
                    formas[i][j] = { top: 0, right: 0, bottom: 0, left: 0 };
                }
            }

            for (let i = 0; i < FILAS; i++) {
                for (let j = 0; j < COLUMNAS; j++) {
                    if (j < COLUMNAS - 1) {
                        let tipo = Math.random() > 0.5 ? 1 : -1;
                        formas[i][j].right = tipo;
                        formas[i][j+1].left = -tipo;
                    }
                    if (i < FILAS - 1) {
                        let tipo = Math.random() > 0.5 ? 1 : -1;
                        formas[i][j].bottom = tipo;
                        formas[i+1][j].top = -tipo;
                    }
                }
            }

            for (let i = 0; i < FILAS; i++) {
                for (let j = 0; j < COLUMNAS; j++) {
                    piezas.push({
                        filaCorrecta: i,
                        colCorrecta: j,
                        xCorrecta: j * anchoPieza,
                        yCorrecta: i * altoPieza,
                        x: 0, y: 0,
                        bloqueada: false,
                        sx: (j * anchoPieza) / scale, // Coordenada origen en imagen real
                        sy: (i * altoPieza) / scale,
                        sw: (anchoPieza) / scale,
                        sh: (altoPieza) / scale,
                        forma: formas[i][j]
                    });
                }
            }
        }

        function mezclarPiezas() {
            for (let pieza of piezas) {
                pieza.x = Math.random() * (canvas.width - anchoPieza);
                pieza.y = Math.random() * (canvas.height - altoPieza);
            }
        }

        function trazarContornoPuzzle(ctx, x, y, w, h, forma) {
            ctx.beginPath();
            ctx.moveTo(x, y);
            // Top
            forma.top !== 0 ? dibujarLado(ctx, x, y, x + w, y, forma.top) : ctx.lineTo(x + w, y);
            // Right
            forma.right !== 0 ? dibujarLado(ctx, x + w, y, x + w, y + h, forma.right) : ctx.lineTo(x + w, y + h);
            // Bottom
            forma.bottom !== 0 ? dibujarLado(ctx, x + w, y + h, x, y + h, forma.bottom) : ctx.lineTo(x, y + h);
            // Left
            forma.left !== 0 ? dibujarLado(ctx, x, y + h, x, y, forma.left) : ctx.lineTo(x, y);
            ctx.closePath();
        }

        function dibujarLado(ctx, x1, y1, x2, y2, tipo) {
            const w = x2 - x1;
            const h = y2 - y1;
            const cx = (x1 + x2) / 2;
            const cy = (y1 + y2) / 2;
            const esHorizontal = Math.abs(w) > Math.abs(h);
            const s = tipo * tamanoPestana; 

            if (esHorizontal) {
                ctx.bezierCurveTo(x1 + w * 0.4, y1, x1 + w * 0.4, y1 + s, cx, y1 + s);
                ctx.bezierCurveTo(x2 - w * 0.4, y2 + s, x2 - w * 0.4, y2, x2, y2);
            } else {
                ctx.bezierCurveTo(x1, y1 + h * 0.4, x1 + s, y1 + h * 0.4, x1 + s, cy);
                ctx.bezierCurveTo(x2 + s, y2 - h * 0.4, x2, y2 - h * 0.4, x2, y2);
            }
        }

        function dibujarJuego() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Fondo tenue
            ctx.save();
            ctx.globalAlpha = 0.15;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            ctx.restore();

            // Dibujar primero las piezas NO seleccionadas
            for (let pieza of piezas) {
                if (pieza === piezaSeleccionada) continue;
                dibujarPiezaIndividual(pieza);
            }

            // Dibujar la pieza seleccionada AL FINAL (encima de todas)
            if (piezaSeleccionada) {
                // Sombra de elevaci√≥n
                ctx.save();
                ctx.shadowColor = "rgba(0,0,0,0.5)";
                ctx.shadowBlur = 15;
                ctx.shadowOffsetX = 5;
                ctx.shadowOffsetY = 5;
                dibujarPiezaIndividual(piezaSeleccionada);
                ctx.restore();
            }
        }

        function dibujarPiezaIndividual(pieza) {
            ctx.save();
            trazarContornoPuzzle(ctx, pieza.x, pieza.y, anchoPieza, altoPieza, pieza.forma);
            ctx.clip();
            
            // Dibujar la parte de la imagen correspondiente
            // Usamos las coordenadas originales de la imagen (sx, sy) escaladas al canvas
            const expansion = tamanoPestana * 1.5;
            const ratioW = img.width / canvas.width;
            const ratioH = img.height / canvas.height;

            ctx.drawImage(
                img,
                (pieza.xCorrecta * ratioW) - (expansion * ratioW), 
                (pieza.yCorrecta * ratioH) - (expansion * ratioH),
                (anchoPieza * ratioW) + (expansion * ratioW * 2), 
                (altoPieza * ratioH) + (expansion * ratioH * 2),
                pieza.x - expansion, 
                pieza.y - expansion,
                anchoPieza + (expansion * 2), 
                altoPieza + (expansion * 2)
            );
            ctx.restore();

            // Borde
            ctx.save();
            trazarContornoPuzzle(ctx, pieza.x, pieza.y, anchoPieza, altoPieza, pieza.forma);
            ctx.strokeStyle = pieza.bloqueada ? "#27ae60" : "rgba(255,255,255,0.8)";
            ctx.lineWidth = pieza.bloqueada ? 1 : 2;
            ctx.stroke();
            ctx.restore();
        }

        function verificarVictoria() {
            actualizarProgreso();
            const ganaste = piezas.every(p => p.bloqueada);
            if (ganaste) {
                detenerCronometro(); // DETENER TIEMPO
                
                // Animaci√≥n final
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                
                // Mostrar overlay y mensaje
                overlay.style.display = 'block';
                winMsg.style.display = 'block';
                finalTimeDisplay.textContent = tiempoFinal;
            }
        }

        // EVENTOS MOUSE
        canvas.onmousedown = function(e) {
            // INICIAR CRON√ìMETRO AL PRIMER CLIC
            iniciarCronometro();

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Buscar pieza (reverso para agarrar la que est√° visualmente arriba)
            for (let i = piezas.length - 1; i >= 0; i--) {
                let p = piezas[i];
                if (!p.bloqueada && 
                    mouseX > p.x && mouseX < p.x + anchoPieza &&
                    mouseY > p.y && mouseY < p.y + altoPieza) {
                    
                    piezaSeleccionada = p;
                    piezaSeleccionada.desfaseX = mouseX - p.x;
                    piezaSeleccionada.desfaseY = mouseY - p.y;
                    
                    // Mover al final del array para que se dibuje √∫ltima (encima)
                    piezas.splice(i, 1);
                    piezas.push(piezaSeleccionada);
                    
                    dibujarJuego();
                    return;
                }
            }
        };

        canvas.onmousemove = function(e) {
            if (piezaSeleccionada) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                piezaSeleccionada.x = mouseX - piezaSeleccionada.desfaseX;
                piezaSeleccionada.y = mouseY - piezaSeleccionada.desfaseY;
                dibujarJuego();
            }
        };

        canvas.onmouseup = function() {
            if (piezaSeleccionada) {
                const dist = Math.hypot(
                    piezaSeleccionada.x - piezaSeleccionada.xCorrecta,
                    piezaSeleccionada.y - piezaSeleccionada.yCorrecta
                );

                if (dist < MARGEN_ERROR) {
                    piezaSeleccionada.x = piezaSeleccionada.xCorrecta;
                    piezaSeleccionada.y = piezaSeleccionada.yCorrecta;
                    piezaSeleccionada.bloqueada = true;
                    // Sonido de encaje opcional
                    // new Audio('click.mp3').play().catch(e=>{}); 
                }

                piezaSeleccionada = null;
                dibujarJuego();
                verificarVictoria();
            }
        };
    </script>
</body>
</html>