<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puzzle - Diseño de Experimentos</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@600;700&family=Roboto:wght@400;500&family=Roboto+Mono:wght@500&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #34495e;
            --accent-color: #3498db;
            --success-color: #27ae60;
            --text-color: #333;
            --glass-bg: rgba(255, 255, 255, 0.85);
            --glass-border: rgba(255, 255, 255, 0.5);
            --shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.1);
        }

        body {
            font-family: 'Roboto', sans-serif;
            /* Fondo elegante con degradado sutil minimalista */
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            color: var(--text-color);
            padding: 20px;
            box-sizing: border-box;
        }

        /* --- HEADER --- */
        header {
            text-align: center;
            margin-bottom: 25px;
            margin-top: 10px;
        }

        h1 {
            font-family: 'Montserrat', sans-serif;
            font-size: 2.2rem;
            margin: 0;
            color: var(--primary-color);
            letter-spacing: -0.5px;
            text-transform: uppercase;
        }

        .subtitle {
            font-size: 1.1rem;
            color: var(--secondary-color);
            font-weight: 500;
            margin-top: 5px;
            letter-spacing: 1px;
            opacity: 0.8;
        }

        /* --- DASHBOARD (Panel de Estadísticas) --- */
        .dashboard {
            display: flex;
            gap: 40px;
            margin-bottom: 25px;
            padding: 15px 40px;
            border-radius: 16px;
            
            /* Efecto Glassmorphism */
            background: var(--glass-bg);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow);
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 100px;
        }

        .stat-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            color: #7f8c8d;
            letter-spacing: 1.5px;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .stat-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 1.6rem;
            color: var(--primary-color);
            font-weight: 600;
        }

        .divider {
            width: 1px;
            background: rgba(0,0,0,0.1);
        }

        /* --- JUEGO (Canvas) --- */
        #game-container {
            position: relative;
            border-radius: 12px;
            /* Sombra suave para dar efecto de elevación "flotante" */
            box-shadow: 0 20px 60px rgba(0,0,0,0.15);
            background-color: #e0e0e0; /* Color de fondo mientras carga */
            line-height: 0;
            overflow: hidden;
            border: 8px solid white;
        }

        canvas {
            display: block;
            cursor: grab;
            touch-action: none;
        }

        canvas:active {
            cursor: grabbing;
        }

        /* --- FOOTER (Autores) --- */
        footer {
            margin-top: auto; /* Empuja el footer al fondo si sobra espacio */
            padding-top: 30px;
            text-align: center;
            font-size: 0.9rem;
            color: var(--secondary-color);
        }

        .authors {
            font-weight: 500;
            margin-bottom: 5px;
        }

        .course-info {
            font-size: 0.85rem;
            opacity: 0.7;
        }

        /* --- MENSAJE VICTORIA --- */
        #win-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(44, 62, 80, 0.7); /* Oscuro profesional */
            backdrop-filter: blur(8px);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }

        .win-card {
            background: white;
            padding: 50px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 25px 50px rgba(0,0,0,0.25);
            animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            max-width: 400px;
            width: 90%;
        }

        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        .win-title {
            color: var(--success-color);
            margin: 0 0 10px 0;
            font-family: 'Montserrat', sans-serif;
            font-size: 2rem;
        }

        .btn-restart {
            margin-top: 25px;
            padding: 12px 35px;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 30px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }
        .btn-restart:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }

    </style>
</head>
<body>

    <header>
        <h1>Experimento de Armado</h1>
        <div class="subtitle">Diseño de Experimentos</div>
    </header>

    <div class="dashboard">
        <div class="stat-item">
            <span class="stat-label">Tiempo</span>
            <span class="stat-value" id="timer">00:00.00</span>
        </div>
        <div class="divider"></div>
        <div class="stat-item">
            <span class="stat-label">Piezas</span>
            <span class="stat-value" id="progress">0 / 64</span>
        </div>
    </div>

    <div id="game-container">
        <canvas id="miCanvas"></canvas>
    </div>

    <footer>
        <div class="authors">Daniel Enrique Arias Montero &bull; Abraham José Gómez Sarmiento</div>
        <div class="course-info">Ingeniería &bull; 2025</div>
    </footer>

    <div id="win-overlay">
        <div class="win-card">
            <h2 class="win-title">¡Excelente!</h2>
            <p style="color: #666; font-size: 1.1rem;">Experimento completado con éxito.</p>
            <div style="background: #f8f9fa; padding: 15px; border-radius: 10px; margin: 20px 0; border: 1px solid #eee;">
                <span class="stat-label">Tiempo Final</span><br>
                <span class="stat-value" id="final-time">00:00.00</span>
            </div>
            <button class="btn-restart" onclick="location.reload()">Nuevo Intento</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('miCanvas');
        const ctx = canvas.getContext('2d');
        const timerDisplay = document.getElementById('timer');
        const progressDisplay = document.getElementById('progress');
        const winOverlay = document.getElementById('win-overlay');
        const finalTimeDisplay = document.getElementById('final-time');

        // --- CONFIGURACIÓN ---
        const FILAS = 8;
        const COLUMNAS = 8;
        // ¡IMPORTANTE! Asegúrate que esta ruta sea correcta
        const RUTA_IMAGEN = 'foto.jpg'; 
        const MARGEN_ERROR = 35; 
        
        let img = new Image();
        let piezas = [];
        let anchoPiezaCanvas, altoPiezaCanvas;
        let anchoPiezaImg, altoPiezaImg;
        let piezaSeleccionada = null;
        let tamanoPestana;
        let escalaGlobal; 
        
        // Variables Timer
        let startTime = 0;
        let timerInterval;
        let running = false;
        let totalPiezas = FILAS * COLUMNAS;

        img.src = RUTA_IMAGEN;

        img.onload = function() {
            // Ajustar canvas para que no sea gigante en pantallas grandes, pero ocupe buen espacio
            const maxWidth = Math.min(900, window.innerWidth - 40);
            escalaGlobal = maxWidth / img.width;
            
            canvas.width = maxWidth;
            canvas.height = img.height * escalaGlobal;

            anchoPiezaCanvas = canvas.width / COLUMNAS;
            altoPiezaCanvas = canvas.height / FILAS;
            
            anchoPiezaImg = img.width / COLUMNAS;
            altoPiezaImg = img.height / FILAS;

            // Tamaño de pestaña ajustado
            tamanoPestana = Math.min(anchoPiezaCanvas, altoPiezaCanvas) * 0.25;

            inicializarJuego();
        };

        function inicializarJuego() {
            piezas = [];
            let formas = [];

            // Generar formas coincidentes
            for(let i=0; i<FILAS; i++) {
                formas[i] = [];
                for(let j=0; j<COLUMNAS; j++) {
                    formas[i][j] = { top: 0, right: 0, bottom: 0, left: 0 };
                }
            }

            for(let i=0; i<FILAS; i++) {
                for(let j=0; j<COLUMNAS; j++) {
                    if(j < COLUMNAS-1) {
                        let tipo = Math.random() > 0.5 ? 1 : -1;
                        formas[i][j].right = tipo;
                        formas[i][j+1].left = -tipo;
                    }
                    if(i < FILAS-1) {
                        let tipo = Math.random() > 0.5 ? 1 : -1;
                        formas[i][j].bottom = tipo;
                        formas[i+1][j].top = -tipo;
                    }
                }
            }

            for(let i=0; i<FILAS; i++) {
                for(let j=0; j<COLUMNAS; j++) {
                    piezas.push({
                        imgX: j * anchoPiezaImg,
                        imgY: i * altoPiezaImg,
                        xCorrecta: j * anchoPiezaCanvas,
                        yCorrecta: i * altoPiezaCanvas,
                        // Esparcir piezas aleatoriamente
                        x: Math.random() * (canvas.width - anchoPiezaCanvas),
                        y: Math.random() * (canvas.height - altoPiezaCanvas),
                        forma: formas[i][j],
                        bloqueada: false
                    });
                }
            }
            dibujarEscena();
        }

        // --- FORMA CLÁSICA DE PUZZLE (Bombilla / Llave) ---
        function trazarPieza(ctx, x, y, w, h, forma) {
            ctx.beginPath();
            ctx.moveTo(x, y);
            // Top (Izq -> Der)
            dibujarLadoVectorial(ctx, x, y, x + w, y, forma.top);
            // Right (Arr -> Aba)
            dibujarLadoVectorial(ctx, x + w, y, x + w, y + h, forma.right);
            // Bottom (Der -> Izq)
            dibujarLadoVectorial(ctx, x + w, y + h, x, y + h, forma.bottom);
            // Left (Aba -> Arr)
            dibujarLadoVectorial(ctx, x, y + h, x, y, forma.left);
            ctx.closePath();
        }

        function dibujarLadoVectorial(ctx, x1, y1, x2, y2, tipo) {
            if (tipo === 0) {
                ctx.lineTo(x2, y2);
                return;
            }

            // Vectores básicos
            const dx = x2 - x1;
            const dy = y2 - y1;
            const len = Math.hypot(dx, dy);

            // Vector Normal (90 grados)
            const nx = dy / len;
            const ny = -dx / len;

            // Tamaño de la oreja
            const s = tipo * tamanoPestana; 

            // Puntos clave para la forma de "Bombilla" clásica
            const xBase1 = x1 + dx * 0.34;
            const yBase1 = y1 + dy * 0.34;
            
            const xBase2 = x1 + dx * 0.66;
            const yBase2 = y1 + dy * 0.66;

            const cx = x1 + dx * 0.5; // Centro X
            const cy = y1 + dy * 0.5; // Centro Y

            // 1. Hombro izquierdo
            ctx.lineTo(xBase1, yBase1);

            // 2. Curva de subida (lado izquierdo de la oreja)
            // Se usa Bezier para crear el "cuello" y la parte gorda de la cabeza
            ctx.bezierCurveTo(
                xBase1 + nx * s * 0.2, yBase1 + ny * s * 0.2, // CP1
                xBase1 + nx * s * 1.0, yBase1 + ny * s * 1.0, // CP2
                cx + nx * s * 1.0, cy + ny * s * 1.0 // Cima
            );

            // 3. Curva de bajada (lado derecho de la oreja)
            ctx.bezierCurveTo(
                xBase2 + nx * s * 1.0, yBase2 + ny * s * 1.0, // CP1
                xBase2 + nx * s * 0.2, yBase2 + ny * s * 0.2, // CP2
                xBase2, yBase2 // Base derecha
            );

            // 4. Hombro derecho
            ctx.lineTo(x2, y2);
        }

        function dibujarEscena() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Fondo guía (fantasma)
            ctx.save();
            ctx.globalAlpha = 0.15;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            ctx.restore();

            piezas.forEach(p => {
                if(p !== piezaSeleccionada) dibujarPieza(p);
            });

            // Pieza seleccionada siempre arriba con sombra pronunciada
            if(piezaSeleccionada) {
                ctx.shadowColor = "rgba(0,0,0,0.4)";
                ctx.shadowBlur = 20;
                ctx.shadowOffsetX = 10;
                ctx.shadowOffsetY = 10;
                dibujarPieza(piezaSeleccionada);
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            }
        }

        // --- RENDERIZADO AVANZADO (Con corrección de espacios blancos) ---
        function dibujarPieza(p) {
            ctx.save();
            ctx.translate(p.x, p.y);

            // 1. Recorte (Shape)
            trazarPieza(ctx, 0, 0, anchoPiezaCanvas, altoPiezaCanvas, p.forma);
            ctx.clip();

            // 2. Imagen con Sangrado (Bleed - Solución de bordes blancos)
            const margenSeguridad = Math.max(anchoPiezaCanvas, altoPiezaCanvas) * 0.5;
            const margenImg = margenSeguridad / escalaGlobal;

            let sx = p.imgX - margenImg;
            let sy = p.imgY - margenImg;
            let sw = anchoPiezaImg + (margenImg * 2);
            let sh = altoPiezaImg + (margenImg * 2);

            let dx = -margenSeguridad;
            let dy = -margenSeguridad;
            let dw = anchoPiezaCanvas + (margenSeguridad * 2);
            let dh = altoPiezaCanvas + (margenSeguridad * 2);

            ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);

            // 3. Bordes
            trazarPieza(ctx, 0, 0, anchoPiezaCanvas, altoPiezaCanvas, p.forma);
            ctx.lineWidth = 1.5;
            if (p.bloqueada) {
                ctx.strokeStyle = "rgba(255, 255, 255, 0.2)"; // Casi invisible si encaja
                ctx.stroke();
            } else {
                ctx.strokeStyle = "rgba(255, 255, 255, 0.9)"; // Blanco brillante si flota
                ctx.stroke();
                // Sombra interior sutil para volumen
                ctx.shadowColor = "rgba(0,0,0,0.2)";
                ctx.shadowBlur = 2;
                ctx.stroke();
                ctx.shadowColor = "transparent";
            }

            ctx.restore();
        }

        // --- FUNCIONES DE JUEGO ---
        function empezarTimer() {
            if(!running) {
                running = true;
                startTime = Date.now();
                timerInterval = setInterval(() => {
                    let delta = Date.now() - startTime;
                    timerDisplay.textContent = formatearTiempo(delta);
                }, 50);
            }
        }

        function detenerTimer() {
            running = false;
            clearInterval(timerInterval);
            let final = formatearTiempo(Date.now() - startTime);
            finalTimeDisplay.textContent = final;
            return final;
        }

        function formatearTiempo(ms) {
            let s = Math.floor(ms / 1000);
            let m = Math.floor(s / 60);
            let cs = Math.floor((ms % 1000) / 10);
            s = s % 60;
            return `${pad(m)}:${pad(s)}.${pad(cs)}`;
        }
        function pad(n) { return n < 10 ? '0'+n : n; }

        function checkVictoria() {
            const encajadas = piezas.filter(p => p.bloqueada).length;
            progressDisplay.textContent = `${encajadas} / ${totalPiezas}`;
            
            if(encajadas === totalPiezas) {
                detenerTimer();
                // Limpiar y mostrar imagen completa final
                ctx.clearRect(0,0,canvas.width, canvas.height);
                ctx.drawImage(img, 0,0, canvas.width, canvas.height);
                winOverlay.style.display = 'flex';
            }
        }

        // Eventos Mouse
        canvas.onmousedown = function(e) {
            empezarTimer();
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            for(let i=piezas.length-1; i>=0; i--) {
                let p = piezas[i];
                if(!p.bloqueada && 
                   mx > p.x && mx < p.x + anchoPiezaCanvas && 
                   my > p.y && my < p.y + altoPiezaCanvas) {
                    
                    piezaSeleccionada = p;
                    piezaSeleccionada.offX = mx - p.x;
                    piezaSeleccionada.offY = my - p.y;
                    
                    // Traer al frente
                    piezas.splice(i, 1);
                    piezas.push(p);
                    
                    dibujarEscena();
                    return;
                }
            }
        };

        canvas.onmousemove = function(e) {
            if(piezaSeleccionada) {
                const rect = canvas.getBoundingClientRect();
                piezaSeleccionada.x = (e.clientX - rect.left) - piezaSeleccionada.offX;
                piezaSeleccionada.y = (e.clientY - rect.top) - piezaSeleccionada.offY;
                dibujarEscena();
            }
        };

        canvas.onmouseup = function() {
            if(piezaSeleccionada) {
                const dist = Math.hypot(piezaSeleccionada.x - piezaSeleccionada.xCorrecta, piezaSeleccionada.y - piezaSeleccionada.yCorrecta);
                if(dist < MARGEN_ERROR) {
                    piezaSeleccionada.x = piezaSeleccionada.xCorrecta;
                    piezaSeleccionada.y = piezaSeleccionada.yCorrecta;
                    piezaSeleccionada.bloqueada = true;
                }
                piezaSeleccionada = null;
                dibujarEscena();
                checkVictoria();
            }
        };

        // Soporte Táctil
        canvas.addEventListener('touchstart', function(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', { clientX: touch.clientX, clientY: touch.clientY });
            canvas.dispatchEvent(mouseEvent);
        }, {passive: false});

        canvas.addEventListener('touchmove', function(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', { clientX: touch.clientX, clientY: touch.clientY });
            canvas.dispatchEvent(mouseEvent);
        }, {passive: false});

        canvas.addEventListener('touchend', function(e) {
            const mouseEvent = new MouseEvent('mouseup', {});
            canvas.dispatchEvent(mouseEvent);
        });

    </script>
</body>
</html>