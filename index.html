<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puzzle - Diseño de Experimentos</title>
    <style>
        /* ESTILOS PROFESIONALES */
        :root {
            --primary-color: #2c3e50;
            --accent-color: #3498db;
            --text-light: #ecf0f1;
            --bg-color: #eef2f3;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background: var(--bg-color);
            color: #333;
        }

        header {
            background-color: var(--primary-color);
            color: var(--text-light);
            width: 100%;
            padding: 1rem 0;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        h1 { margin: 0; font-size: 1.8rem; font-weight: 600; }
        h2 { margin: 5px 0 0; font-size: 1rem; font-weight: 300; opacity: 0.9; }

        #game-container {
            position: relative;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            border: 5px solid #fff;
            border-radius: 4px;
            background-color: #ddd; /* Color de fondo del tablero vacío */
        }

        canvas {
            display: block;
            cursor: grab;
        }
        canvas:active { cursor: grabbing; }

        footer {
            margin-top: 20px;
            font-size: 0.9rem;
            color: #555;
            text-align: center;
            padding-bottom: 20px;
        }

        .credits {
            font-weight: bold;
            color: var(--primary-color);
        }

        /* Mensaje de victoria */
        #win-message {
            display: none;
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(46, 204, 113, 0.95);
            color: white;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
            z-index: 100;
        }
    </style>
</head>
<body>

    <header>
        <h1>Diseño de Experimentos</h1>
        <h2>Rompecabezas Interactivo</h2>
    </header>

    <div id="game-container">
        <canvas id="miCanvas"></canvas>
    </div>

    <div id="win-message">
        <h1>¡Excelente Trabajo!</h1>
        <p>Has completado el experimento correctamente.</p>
        <button onclick="location.reload()" style="padding: 10px 20px; cursor:pointer;">Reiniciar</button>
    </div>

    <footer>
        Desarrollado por:<br>
        <span class="credits">Daniel Enrique Arias Montero & Abraham José Gómez Sarmiento</span>
    </footer>

    <script>
        const canvas = document.getElementById('miCanvas');
        const ctx = canvas.getContext('2d');
        const winMsg = document.getElementById('win-message');
        
        // CONFIGURACIÓN
        const FILAS = 8;
        const COLUMNAS = 8;
        const RUTA_IMAGEN = 'foto.jpg'; // Tu imagen
        const MARGEN_ERROR = 30; // Distancia en px para que la pieza se "pegue" sola
        
        let piezas = [];
        let anchoPieza, altoPieza;
        let piezaSeleccionada = null;
        let img = new Image();

        // Sonidos (Opcional: puedes quitarlos si no tienes archivos, o usar URLs online)
        // const audioClick = new Audio('click.mp3'); 

        img.src = RUTA_IMAGEN;
        
        img.onload = function() {
            // Ajustamos el tamaño del canvas al de la imagen
            // (Si la imagen es muy grande, podrías escalar aquí)
            canvas.width = img.width;
            canvas.height = img.height;
            
            anchoPieza = img.width / COLUMNAS;
            altoPieza = img.height / FILAS;

            inicializarPiezas();
            mezclarPiezas();
            dibujarJuego();
        };

        function inicializarPiezas() {
            piezas = [];
            for (let i = 0; i < FILAS; i++) {
                for (let j = 0; j < COLUMNAS; j++) {
                    piezas.push({
                        filaCorrecta: i,
                        colCorrecta: j,
                        // Posición destino (donde debe encajar)
                        xCorrecta: j * anchoPieza,
                        yCorrecta: i * altoPieza,
                        // Estado actual
                        x: 0, 
                        y: 0,
                        bloqueada: false, // True si ya está encajada
                        // Recorte de la imagen
                        sx: j * anchoPieza,
                        sy: i * altoPieza
                    });
                }
            }
        }

        function mezclarPiezas() {
            for (let pieza of piezas) {
                // Las ponemos en lugares aleatorios
                pieza.x = Math.random() * (canvas.width - anchoPieza);
                pieza.y = Math.random() * (canvas.height - altoPieza);
            }
        }

        function dibujarJuego() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Primero dibujamos una "guía" muy tenue (opcional, ayuda al usuario)
            ctx.globalAlpha = 0.1;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            ctx.globalAlpha = 1.0;

            // Dibujar piezas
            // Ordenamos para que la seleccionada siempre esté arriba
            for (let pieza of piezas) {
                ctx.save();
                ctx.translate(pieza.x, pieza.y);

                // Sombra para dar efecto 3D si no está bloqueada
                if (!pieza.bloqueada) {
                    ctx.shadowColor = "rgba(0,0,0,0.5)";
                    ctx.shadowBlur = 4;
                    ctx.shadowOffsetX = 2;
                    ctx.shadowOffsetY = 2;
                }

                ctx.drawImage(
                    img,
                    pieza.sx, pieza.sy, anchoPieza, altoPieza,
                    0, 0, anchoPieza, altoPieza
                );

                // Borde de la pieza
                ctx.strokeStyle = pieza.bloqueada ? "rgba(0,255,0,0.3)" : "#333"; // Verde suave si está encajada
                ctx.lineWidth = 1;
                ctx.strokeRect(0, 0, anchoPieza, altoPieza);

                ctx.restore();
            }
        }

        function verificarVictoria() {
            // Revisar si TODAS las piezas están bloqueadas
            const ganaste = piezas.every(p => p.bloqueada);
            if (ganaste) {
                // Dibujamos la imagen completa limpia
                ctx.drawImage(img, 0, 0);
                // Mostrar mensaje
                setTimeout(() => {
                    winMsg.style.display = 'block';
                }, 200);
            }
        }

        // --- EVENTOS DEL MOUSE ---

        canvas.onmousedown = function(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Buscar pieza clicada (que no esté ya bloqueada)
            for (let i = piezas.length - 1; i >= 0; i--) {
                let p = piezas[i];
                if (!p.bloqueada && 
                    mouseX > p.x && mouseX < p.x + anchoPieza &&
                    mouseY > p.y && mouseY < p.y + altoPieza) {
                    
                    piezaSeleccionada = p;
                    piezaSeleccionada.desfaseX = mouseX - p.x;
                    piezaSeleccionada.desfaseY = mouseY - p.y;
                    
                    // Traer al frente en el array
                    piezas.splice(i, 1);
                    piezas.push(piezaSeleccionada);
                    
                    dibujarJuego();
                    return;
                }
            }
        };

        canvas.onmousemove = function(e) {
            if (piezaSeleccionada) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                piezaSeleccionada.x = mouseX - piezaSeleccionada.desfaseX;
                piezaSeleccionada.y = mouseY - piezaSeleccionada.desfaseY;
                
                dibujarJuego();
            }
        };

        canvas.onmouseup = function() {
            if (piezaSeleccionada) {
                // LÓGICA DE AUTO-ENCAJE (SNAP)
                const dist = Math.hypot(
                    piezaSeleccionada.x - piezaSeleccionada.xCorrecta,
                    piezaSeleccionada.y - piezaSeleccionada.yCorrecta
                );

                if (dist < MARGEN_ERROR) {
                    // Si está cerca, la forzamos a la posición correcta
                    piezaSeleccionada.x = piezaSeleccionada.xCorrecta;
                    piezaSeleccionada.y = piezaSeleccionada.yCorrecta;
                    piezaSeleccionada.bloqueada = true;
                    // Efecto visual: parpadeo o borde verde (ya está en el draw)
                }

                piezaSeleccionada = null;
                dibujarJuego();
                verificarVictoria();
            }
        };
    </script>
</body>
</html>